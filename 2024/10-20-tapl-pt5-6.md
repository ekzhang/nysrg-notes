- TAPL, parts 5+6 — [[October 20th, 2024]]
    - Say you have a type variable and you define substitutions with type variables. In some ways, this is like applying __abstractions__ (in the variable sense) to the metatheory of types. Then there are two modes of thinking about this.
        - Your types must be valid for all T->U: this is __parametric polymorphism__.
        - Your type must be valid for at least one T->U, figure out which one: this is __type inference__, otherwise known as __type reconstruction__ in this book.
    - __Constraint typing__ and __unification__ are introduced in this chapter, as per Hindley-Milner.
    - "let-polymorphism" is the practice of allowing each call to a function variable actually use different types, it's a form of polymorphism since the type inference constraints are solved every time you call the function. An argument can't be polymorphic within its body, though.
    - Okay, we talked about the let-polymorphism found in Ocaml, via Hindley-Milner unification. Now let's finally get to System F. The jewel of parametric polymorphism.
        - We introduce type abstraction and type application.
        - Parametric polymorphism has to do with universal quantification, rather than existential. Each type abstraction turns into a quantifier clause.
        - It also gives us recursive types like the omega combinator via self-application.
        - No type inference yet, so you need to explicitly write down the type parameters every time you want to apply a polymorphic function.
        - Well-typed System F terms are normalizing. (Why?)
        - Note that the omega combinator cannot be typed in System F, since it's normalizing. Why? Is there a more direct proof of this, or at least an intuition?
        - However, type reconstruction in System F (even of applications) is undecidable.
    - Impredicative types include themselves, like $$\lambda X. X \to X$$.
    - You can't type the fixed-point combinator in System F. I tried, it just doesn't work. Neither can you type the omega combinator. This means that general recursion is not possible. But you can add a fixed-point combinator __by fiat__, which creates a typed system with recursion.
    - Existential types: operationally is a pair of a type S and a term of type $$[X \mapsto S] T$$.
        - Introduction and elimination forms: packing a type with a term (e.g., a struct), and then unpacking it by using it in a form that cancels out the type.
        - Analogous to importing a module and using its contents, like a C FFI call.
        - "… mechanisms for modularity and abstraction are almost completely orthogonal to the statefulness or statelessness of the abstractions being defined."
        - Existential types can model a form of "abstract" data types, in the OOP privacy sense.
    - Another way of thinking about existential types: you can pack interfaces into a heterogeneous list, where the interfaces themselves can have type variables in their signatures — as long as they're self-contained. That's pretty mind-blowing, but it makes sense.
    - __Kinding__ is a copy of the simply-typed lambda calculus, one level up in type-land. Type constructors have kind * => *. Terms have types, which have kinds. You can keep going more levels up in __pure type theory__, but for programmers, three levels are plenty! (yay, lucky us, no $$\infty$$-categories in this book…)
        - System $$F_\omega$$ is just like System F, but with kinds on each type abstraction. This gives us higher-kinded types like (* => *) => *, which are somewhat esoteric.
        - An example of a higher-kinded type is Monad, since each instance operates on type constructors of kind (* => *).

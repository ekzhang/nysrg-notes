- TAPL, parts 1+2 — [[October 6th, 2024]]
    - 11 people here to read a textbook on type theory together.
    - Intro and math background
        - Type systems help prevent certain classes of unwanted program behavior. They're how we reason mathematically about computation. Typically automatic, with some annotations.
            - If it's strong enough, encoding a specification, we get a proof checker.
            - Type systems are also part of "module languages" — the API of a library.
            - "a safe language is one that protects its own abstractions"
        - Question: What does "constructive" mean?
        - Ok, like 5-6 more people came.
    - Part I: Untyped System
        - Metatheory is the formal study of theory. "Metatheory of subtyping" = what subtyping looks like across type systems.
        - Grammar can summarize a language syntax. Inference rules can also be used to write it.
            - Each term can be "deduced" by the inference rules corresponding to it.
            - This means you can induct on terms since they have a total ordering in size. It's like recursively processing an AST.
        - Operational and denotational semantics: the steps, versus the "domain" analogue.
        - Instance of an evaluation rule, taking steps toward getting values to normal form. Operational semantics allow us to reason about things. We won't talk about denotational semantics in this book at all.
            - Small-step (->) and big-step (double down arrow) operational semantics.
            - You can prove equivalence with structural induction.
        - Untyped lambda calculus
            - One of several core calculi, also pi-calculus (message passing concurrency) and object calculus (OOP).
            - Concrete syntax (characters) to abstract syntax tree simplifies processing. Lexer, parser.
            - Variables vs metavariables are based on the context.
            - Evaluation is by finding a __reducible expression__ "redex" and doing beta-reduction.
            - Evaluation strategy matters for lambda calculus, but it isn't relevant for type systems. So we'll just use call-by-value in this book, since it's familiar to people.
    - Part 2: Simple Types
        - Types based on static information. Interesting that they say "the evaluation gets stuck" as a precise technical property, haha.
        - The typing relationship is __conservative__, some valid expressions don't typecheck.
        - "Safety = Progress + Preservation"
            - Is not stuck, and the result of the next derivation step will have the same type.
        - Typing derivations form a tree, just like evaluation, except it's more conservative.
        - The set of __simple types__ has base types and functions.
        - Typing context $$\Gamma$$ is used to keep track of the types of variables.
        - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Fekzhang%2F_l9Ajm3xv9.png?alt=media&token=1f63aa1a-9ebd-49d7-9e90-df4e09026c0f)
        - T-Abs is an __introduction rule__, and T-App is an __elimination rule__. Together, they are a redex.
        - This terminology is related to the __Curry-Howard correspondence__. Propositions as types. This comes from propositional logic, introducing and removing variables.
        - "In effect, programs are converted back to an untyped form before they are evaluated. This style of semantics can be formalized using an __erasure__ function mapping simply typed terms into the corresponding untyped terms."
        - Two styles
            - Curry-style defines a semantics, then removes some undesired behaviors.
            - Church-style only gives semantics to well-typed terms. We are typing __derivations__, not terms, strictly speaking.

- TAPL, parts 3+4 — [[October 13th, 2024]]
    - There are 9 people in the room, and we're seated around a table. Starting the reading process. Someone points out that STLC + references (Landin's knot) is enough to be Turing complete, since you get loops by assigning a reference to a function continuation — cool!
    - Chapter 15
        - First, STLC with subtyping and records: $$\lambda_{<:}$$
        - Subtyping is codifying the __principle of safe substitution__. $$S <: T$$ means that S can be used everywhere that T is. This adds the rule of __subsumption__.
        - Width subtyping for records: more fields means a __smaller__ type. (Depth subtyping as well, which is covariance, but note that this one is only sound for immutable records.) Together, these are kind of like "ignoring unknown fields" in a nested JSON struct.
        - Function types have contravariant argument type, covariant return type.
        - Coercion semantics marked with double-brackets. Translate a language with subtypes into a language without subtypes.
    - Chapter 16
        - __Algorithmic__ subtyping rules are syntax directed. This is an important part of metatheory of subtyping, since it allows us to efficiently check subtypes, rather than having a more fuzzy set of derivations that is not as obvious how to apply. It's like an `is_subtype()` function.
        - Interestingly enough: subtyping only needs to be done at function application time (or ascription), as otherwise we could just delay it. So TA (algorithmic typing) only has the subtype condition in the application rule, rather than a general x : T -> x : U rule.
        - Joins are union / supertypes, meets are intersection / subtypes.
        - In other words, the "minimal type" of two branches is the join, least upper-bound.
        - Algorithmic subtyping needs to add a couple extra rules for $$\bot$$.
    - Chapter 20
        - `NatList = µX. <nil:Unit, cons:{Nat,X}>;` where $$\mu$$ is an explicit type recursion operator.
        - `Hungry = µA. Nat→A;` takes an integer argument, then returns itself.
        - `Stream = µA. Unit→{Nat,A};` is an iterator type, it returns itself but also a natural number.
        - Construct these types using the fixpoint combinator (Y combinator), named `fix` above. Note that the combinator itself isn't well-typed before, but with recursive types we can write down the type of the `x x` term as `(λx:(µA.A→T). f (x x))`.
        - Thus, recursive types break the __strong normalization__ property.
        - This is really powerful! Untyped lambda calculus can be embedded in a static language with recursive types. (Related to denotational semantics.) `D = µX.X→X`
        - Iso-recursive versus equi-recursive logic — iso-recursive makes it easier to write a typechecker since there's explicit isomorphism, but equi-recursive languages need to do complex unification to work out recursive types.
        - Ry is here and killing it with his type theory knowledge! “Kajung” is here and she invited him, as a coworker from Jane Street. He works on the OCaml compiler, just joined after graduating in June.
